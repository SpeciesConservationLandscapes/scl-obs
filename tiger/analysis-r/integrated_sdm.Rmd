---
title: "Integrated SDM"
author: "Mari Roberts and Jessica Spencer"
date: "10/31/2019"
output: pdf_document
---

# Set up

**Helper Functions and Packages:**

The following code loads packages if they aren't installed on your machine. The functions.R file will also be loaded which contains functions necessary for the model (modified from the Koshkina paper).
  
```{r message=FALSE, warning=FALSE}
# Load packages or install packages if they don't exist
requiredPackages = c('raster',
                     'fields',
                     'mvtnorm',
                     'matrixStats', # matrix functions
                     'readr', # read files
                     'rgdal', 
                     'ggplot2', # visualization
                     'dplyr', # data manipularion
                     'tidyverse',
                     'rgbif', # import ad hoc data from GBIF
                     'tidyr' # data tidying
                     ) 
for(p in requiredPackages){
  if(!require(p,character.only = TRUE)) install.packages(p)
  library(p,character.only = TRUE)
}

# load functions in separate R file
source("functions.r")
```

## Preparing data for the Code
----------------------------------------------------------------------------
*s.occupancy* - raster with background covatiates that effect occupancy
*s.detection* - raster with background covariates that effect detection
*pb.occupancy* - matrix with covariates that effect occupancy in the locations of detected presences of the opportunistic survey
*pb.detection* - matrix with covariates that effect detection in the locations of detected presences of the opportunistic survey
*y.so* - matrix of detection/non detection of the PA surveys
*so.occupancy* - matrix with covariates that effect occupancy in the locations of PA survey sites
*so.detection* - matrix with covariates that effect detection in the locations of PA survey sites in each survey

## Shapefiles

The following shapefile was provided by the SCL Team. The shapefile contains the grid cells of Sumatra, Indonesia. Of these grid cells, 394 were surveyed. Grid cells were surveyed for presences of tigers. Presences and absences of tigers were recorded for each survey replicate.

```{r}
# set working directory for all code here:
setwd("/Users/mari/statistical_consulting/scl-obs/tiger/data")

########################################
# Import data
########################################

###
# 1 Site Occupancy
###

s.o.original = read.csv("Tiger_observation_entry_9_SS_Observations_SUMATRA.csv")

###
# 2 Camera Trap
###

# BBSNP2015 CT data
# Leuser data doesn't have observation date
tiger.CT.observations <- read.csv("Tiger_observation_entry_9_CT_observations_BBSNP_V2.csv")
tiger.CT.entry <- read.csv("Tiger_observation_entry_9_CT_deployments_latlon_BBSNP.csv")

###
# 3 Ad Hoc
###

pb.original <- read.csv("Ad Hoc v9 Sumatra 25NOV2019_V2.csv", skip = 1)
pb.original <- pb.original %>% select(grid = cell.label, 
                    observation.date,
                    observation = Report)

########################################
# Sumatran Grid Cells
########################################

# import Sumatra shapefile of gridcells 
unzip("sumatragridmrgd.zip")
sumatra.map <- readOGR(dsn = ".", layer = "sumatragridmrgd")

# import shapefile of camera lat long and corresponding gridcells
unzip("camera_latlon_gridcode.zip")
camera.gridcode <- readOGR(dsn = ".", layer = "camera_latlon_gridcode")
camera.gridcode <- as.data.frame(camera.gridcode)
```

```{r}
########################################
# Shapefiles of Covariates
########################################

# prob.zip provided by Kim Fischer
folder <- "/Users/mari/statistical_consulting/scl-obs/tiger/data/prob/"

# # create list of all .shp files in folder (case of "shp" matters)
filenames <- list.files(path=folder, pattern=".*shp")

# read in each shp file
for (i in 1:length(filenames)){
  assign(filenames[i], rgdal::readOGR(paste(folder, filenames[i], sep=''))
  # figure out how to raster in this loop?
  )}

# convert to raster layer
ct.hii <- raster(Tiger_observation_entry_9_CT_deployments_latlon_BBSNP_hii.shp)
ct.srtm<-raster(Tiger_observation_entry_9_CT_deployments_latlon_BBSNP_srtm.shp)
ct.hii.Leuser<-raster(Tiger_observation_entry_9_CT_deployments_latlon_Leuser_V2_hii.shp)
ct.srtm.Leuser<-raster(Tiger_observation_entry_9_CT_deployments_latlon_Leuser_V2_srtm.shp)
WibiPuspa_1000pts_hii.shp<-raster(WibiPuspa_1000pts_hii.shp)
WibiPuspa_1000pts_srtm.shp<-raster(WibiPuspa_1000pts_srtm.shp)

# s.occupancy <- 

# s.detection <- 


```

## IMPORT DATA: AD HOC, SITE OCCUPANCY, PRESENCE-ABSENCE DATA, COVARIATES  
----------------------------------------------------------------------------

```{r}
########################################
# Site occupancy data
########################################

# This section expands the dataframe so that there is a row for each time an area is surveyed. For example, if an area is surveyed 5 times, there are 5 rows for it, with the observation==1 on the times where a tiger or tiger signs were seen at the location in question. 

# rename variables
s.o.original = rename(s.o.original, 
                      num.surveys = X..replicates.surveyed,
                      grid = grid.cell.label, 
                      replicate = replicate..)
# populated the 0's 
a = s.o.original %>% 
  filter(observation == 0) %>% 
  crossing(survey =(1:98)) %>% 
  mutate(good.survey = ifelse(survey>num.surveys, NA, 1)) %>% 
  na.omit()
a = dplyr::select(a,-c(good.survey))
# expand the 1's
b = s.o.original %>% 
  filter(observation == 1) %>% 
  crossing(survey =(1:98)) %>% 
  mutate(good.survey = ifelse(survey>num.surveys, NA, 1)) %>%
  na.omit() %>%
  mutate(true.observation = ifelse(survey!=replicate, 0, 1))
b = dplyr::select(b,-c(good.survey,observation)) %>% 
  rename(observation = true.observation)
# combine the two
so.filled =rbind(a,b)
so.filled_a = 
  dplyr::select(so.filled,-c(replicate)) %>%    
  distinct(survey,
           grid,
           start.date,
           observation,
           .keep_all = T)
#find the overlapping observations
onlyOnes = filter(so.filled_a, observation ==1)
onlyZs = filter(so.filled_a, observation == 0)
reps = plyr::match_df(onlyZs, 
                      onlyOnes,
                      on = c("survey",
                             "start.date",
                             "grid"))
# subtract overlapping observations from the expanded set
final.filled = setdiff(so.filled_a,reps)
final.filled$survey_id = cumsum(!duplicated(final.filled[2:4]))
strip.so = dplyr::select(final.filled,observation,survey,survey_id,grid)
###############################
# y.so
###############################
# This next section will take that dataframe and turn it into a matrix of values. Each row will correspond to a survey.  If the survey happened 24 times, then the corresponding row will have 24 columns - either 0 or 1 - to denote whether a tiger was seen or not. The final dataframe is called *y.so*.
# final site occupancy data
y.so = spread(strip.so,survey,observation)

########################################
# Camera trap data
########################################

# includes grids that had CT but no tiger was observed
ct <- plyr::join(tiger.CT.entry, tiger.CT.observations, by = "deployment.ID", type = "full")

# create a variable for the number of replicates per survey (one a day)

# create new variables
ct <- ct %>% mutate(# number of days between pick up and deployment
                    num.surveys = as.Date(as.character(pickup.date.time), 
                                             format="%Y/%m/%d")-
                                     as.Date(as.character(deployment.date.time), 
                                             format="%Y/%m/%d"),
                    # the day that the tiger was observed
                    replicate = as.Date(as.character(pickup.date.time), 
                                             format="%Y/%m/%d")-
                                     as.Date(as.character(observation.date.time), 
                                             format="%m/%d/%Y"))
              # %>% select(camera.latitude, camera.longitude, num.surveys, replicate)

# remove camera locations where the camera was lost
ct <- ct %>% filter(pickup.date.time != "NONE")

# add 0s for where a camera wasn't observed (listed as NAs)
ct$observation.date.time <- as.character(ct$observation.date.time)
ct$observation.date.time[is.na(ct$observation.date.time)] <- 0
ct <- ct %>% mutate(observation = ifelse(observation.date.time == 0, 0, 1))

# add 1s for where there was only one survey and no observation (listed as NAs)
ct$replicate <- as.character(ct$replicate)
ct$replicate[is.na(ct$replicate)] <- 0

ct <- ct %>% select(deployment.ID, num.surveys, grid, observation.date.time, observation, replicate, camera.latitude, camera.longitude)

# rename variables with Kim's gridcell shapefile
camera.gridcode <- camera.gridcode %>% mutate(camera.latitude = lat, 
                                              camera.longitude = lon)

# merge with CT data to see which grid cell the CT are in
ct.merged <- merge(ct, camera.gridcode, by = c("camera.latitude","camera.longitude"))

# drop variables 
ct.merged <- ct.merged %>% select(grid = gridcode,
                                  observation,
                                  num.surveys,
                                  replicate,
                                  observation.date.time)

# populated the 0's 
a = ct.merged %>% 
  filter(observation == 0) %>% 
  crossing(survey =(1:154)) %>% 
  mutate(good.survey = ifelse(survey>num.surveys, NA, 1)) %>% 
  na.omit()

a = dplyr::select(a,-c(good.survey))

# expand the 1's
b = ct.merged %>% 
  filter(observation == 1) %>% 
  crossing(survey =(1:154)) %>% 
  mutate(good.survey = ifelse(survey>num.surveys, NA, 1)) %>%
  na.omit() %>%
  mutate(true.observation = ifelse(survey!=replicate, 0, 1))

b = dplyr::select(b,-c(good.survey,observation)) %>% 
  rename(observation = true.observation)

# combine the two
ct.filled =rbind(a,b)
ct.filled_a = 
  dplyr::select(ct.filled,-c(replicate)) %>%    
  distinct(survey,
           grid,
           observation.date.time,
           observation,
           .keep_all = T)

#find the overlapping observations
onlyOnes = filter(ct.filled_a, observation == 1)
onlyZs = filter(ct.filled_a, observation == 0)
reps = plyr::match_df(onlyZs, 
                      onlyOnes,
                      on = c("survey",
                             "observation.date.time",
                             "grid"))
# subtract overlapping observations from the expanded set
final.filled = setdiff(ct.filled_a,reps)
final.filled$survey_id = cumsum(!duplicated(final.filled[2:4]))
strip.ct = dplyr::select(final.filled,observation,survey,survey_id,grid)

y.ct = spread(strip.ct,survey,observation)

########################################
# Ad hoc data
########################################

###############################
# pb.occupancy - matrix with covariates that effect occupancy in the locations of detected presences 
# pb.detection - matrix with covariates that effect detection in the locations of detected presences 
###############################

# Ad hoc data only has grid cell???

# pb.loc=SpatialPoints(pb)
# pb.occupancy=extract(s.occupancy,pb.loc)
# pb.detection=extract(s.detection,pb.loc)
# 
# is.complete.pb=complete.cases(pb.detection)&complete.cases(pb.occupancy)
# pb.detection=pb.detection[is.complete.pb,]
# pb.occupancy=pb.occupancy[is.complete.pb,]
```


```{r}
# Only use complete cases
print("removing NA")
is.complete=complete.cases(so.occupancy)&complete.cases(so.detection)&complete.cases(y.so)
so.occupancy=so.occupancy[is.complete,]
so.detection=so.detection[is.complete,]
y.so=y.so[is.complete,]
area.so =pi*0.04

#removing rasters to free the memory
print('removing raster files')
for (i in c(x.files,w.files)) {
	do.call(remove,list(i))
}
remove(is.complete.pb,po,yb.so,po.loc)
```

## Preparing the Data for the Integrated Model

```{r}
# 1. Preparing the data ========================================================
#Preparing Presence-Only data ------------------------------------------------

#turning rasters into tables - background, adding column of ones
X.back = cbind(rep(1, ncell(s.occupancy)), values(s.occupancy))
colnames(X.back)=c("",names(s.occupancy))
W.back = cbind(rep(1, ncell(s.detection)), values(s.detection))
colnames(W.back)=c("",names(s.detection))
# remove all NA values
tmp=X.back[complete.cases(X.back)&complete.cases(W.back),]
W.back=W.back[complete.cases(X.back)&complete.cases(W.back),]
X.back=tmp

#area in squared km -----------------------------------
area.back = rep((xres(s.occupancy)/1000)*(yres(s.occupancy)/1000), nrow(X.back))# each cell
s.area=area.back*nrow(X.back) #study area

# adding column of ones - pb locations
X.po=cbind(rep(1, nrow(as.matrix(pb.occupancy))), pb.occupancy)
W.po=cbind(rep(1, nrow(as.matrix(pb.detection))), pb.detection)

#Preparing Presence-Absence data ------------------------------------------------

#add a column of ones to the PA covariat
#y.so # matrix of presences and absences (when the species was and wasn't present)
J.so=ncol(y.so)
X.so=cbind(rep(1, nrow(as.matrix(so.occupancy))), so.occupancy)
W.so = array(dim=c(nrow(as.matrix(so.detection)), J.so, 3))
W.so[,,1] = 1
#this changes it to a list
# W.so[,,2] = as.matrix(so.detection[,1:2])# if it changes
W.so[,,2] = so.detection# if it changes
#sometimes this (the line below) runs, sometimes it doesnt 
# W.so[,,3] = as.matrix(so.detection[,3:4])# if it changes
```

## Analyzing Data 

### Presence-Only 

Uses a function that fits IPP model. There appears to be an error in the function: 

Error in eigen(hess) : infinite or missing values in 'x'

```{r}
#Analyzing Presence-Only data
#missing values in X
pb.fit=pb.ipp(X.po, W.po,X.back, W.back)
printList(pb.fit)
```

### Presence-Absence 

Uses a function that fits Mackenzie model. 
Error in base::rowSums(x, na.rm = na.rm, dims = dims, ...) : 'x' must be numeric
y.so different number of surveys
could also be an issue with so.detection and so.occupancy
Error in fn(par, ...) : unused argument (trace = 6)

```{r}
# Analyzing presence-absence data
#X must be numeric
so.fit=so.model(X.so,W.so,y.so)
str(y.so)
printList(so.fit)
```

### Integrated Model

Uses a function that fits the integrated model.

Error in base::rowSums(x, na.rm = na.rm, dims = dims, ...) : 'x' must be numeric

```{r}
# Analyzing presence-only data AND presence-absence data
poANDso.fit=pbso.integrated(X.po, W.pb,X.back, W.back,X.so,W.so,y.so)

#### Save model results
save(pb.fit, so.fit, poANDso.fit, file="model.results.rda")

printList(poANDso.fit)
```













